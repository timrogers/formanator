import { createReadStream, existsSync } from 'fs';

import { type CreateClaimOptions, getCategoriesForBenefitName } from './forma.js';
import { parse } from '@fast-csv/parse';

export interface Claim {
  category: string;
  benefit: string;
  amount: string;
  merchant: string;
  purchaseDate: string;
  description: string;
  receiptPath: string[];
}

const PURCHASE_DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

export const isValidPurchaseDate = (purchaseDate: string): boolean =>
  PURCHASE_DATE_REGEX.test(purchaseDate);

const AMOUNT_REGEX = /^\d+(\.\d{2})?$/;

export const isValidAmount = (amount: string): boolean => AMOUNT_REGEX.test(amount);

export const claimParamsToCreateClaimOptions = async (
  claim: Claim,
  accessToken: string,
): Promise<CreateClaimOptions> => {
  const categories = await getCategoriesForBenefitName(accessToken, claim.benefit);

  const matchingCategory = categories.find(
    (category) =>
      category.subcategory_alias === claim.category ||
      category.subcategory_name === claim.category,
  );

  if (matchingCategory == null) {
    throw new Error(
      `No category '${claim.category}' found for benefit '${claim.benefit}'.`,
    );
  }

  if (!isValidPurchaseDate(claim.purchaseDate))
    throw new Error('Purchase date must be in YYYY-MM-DD format.');
  if (!isValidAmount(claim.amount)) throw new Error('Amount must be in the format 0.00.');

  for (const path of claim.receiptPath) {
    if (!existsSync(path)) {
      throw new Error(`Receipt path '${path}' does not exist.`);
    }
  }

  return {
    ...claim,
    accessToken,
    benefitId: matchingCategory.benefit_id,
    categoryId: matchingCategory.category_id,
    subcategoryAlias: matchingCategory.subcategory_alias,
    subcategoryValue: matchingCategory.subcategory_value,
  };
};

const EXPECTED_CSV_HEADERS = [
  'category',
  'benefit',
  'amount',
  'merchant',
  'purchaseDate',
  'description',
  'receiptPath',
];

export const readClaimsFromCsv = async (inputPath: string): Promise<Claim[]> => {
  const claims: Claim[] = [];

  return await new Promise((resolve, reject) => {
    createReadStream(inputPath, 'utf8')
      .pipe(parse({ headers: true }))
      .on('error', reject)
      .on('data', (row) => {
        const rowHeaders = Object.keys(row);

        if (
          rowHeaders.length !== EXPECTED_CSV_HEADERS.length ||
          !rowHeaders.every((header) => EXPECTED_CSV_HEADERS.includes(header))
        ) {
          reject(
            new Error(
              'Invalid CSV headers. Please use a template CSV generated by the `generate-template-csv` command.',
            ),
          );
        }

        const receiptPath = row.receiptPath.split(',').map((path) => path.trim());
        const claim: Claim = { ...row, receiptPath };

        claims.push(claim);
      })
      .on('end', () => {
        resolve(claims);
      });
  });
};
